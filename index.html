Please say hi on <a href="https://mastodon.social/@saikyun">mastodon.social/@saikyun</a>. :)

<hr />

<h1>Web Assembly</h1>
<p>Yesterday I posted my first blog on <a href="http://kodsnack.se">Kodsnack</a>'s slack channel, and got some feedback on my woes about programming.</p>
<p>Some said that zig and r*** might be good languages to look at, and I argued a bit about how they appear to me as languages that doesn't have the same goals in mind as me. I think being able to (compile and) execute code with &lt;200ms delay is important, since I find it pleasant when working on things like animations and layouts. Needing to wait even a second while modifying an animation feels painful to me.</p>
<p>I want to be clear and say that I do think zig and rust are interesting (and probably good) languages, and it's a difference in priorities and aesthetics, not in some objective &quot;good&quot;ness. So if you do enjoy zig / rust, please keep rocking on. :)</p>
<p>I also got some kind words about <a href="https://github.com/saikyun/freja">Freja</a>, which I really appreciate.</p>
<p>The last thing that came up was the subject of WASM. Being interested in both web and games, I've been curious about WASM since it's inception. I still remember playing some Quake or DOOM demo in the browser, and it seemed kind of magical. I never did anything with it though, since at the time I was busy writing web apps in node and play League of Legends.</p>
<p>Last summer I started wondering if assembly is a good target for live coding, since it's very flexible (just swap out the byte code right?). It seemed very tricky to write a multi platform compiler though.</p>
<p>When camping with my family, I started reading about <a href="https://100r.co/site/uxn.html">uxn</a>, and <a href="https://wiki.xxiivv.com/site/paper_computing.html">pen &amp; paper computing</a>).</p>
<p>In the paper prototyping site, they mention that you can compute using a really small instruction set:</p>
<blockquote>
<p>The following three counter machine models have the same computational power since the instructions of one model can be derived from those of another:</p>
</blockquote>
<blockquote>
<p>INC(r), DEC(r), JZ(r, z) - Minsky (1961, 1967), Lambek (1961)</p>
</blockquote>
<blockquote>
<p>CLR(r), INC(r), JE(rj, rk, z) - Ershov (1958), Peter (1958)</p>
</blockquote>
<blockquote>
<p>INC(r), CPY(rj, rk), JE(rj, rk, z) - Elgot-Robinson (1964), Minsky (1967)</p>
</blockquote>
<p>With this knowledge, I made a assembly editor and interpreter using termux. It was pretty fun, and it really fulfilled the minimalist language that I envisioned. It was pretty cool that you see how the registers changed when you ran the program too.</p>
<p>Next step was obviously to make this compile to arm assembly. Arm is the simple one, right? <a href="https://developer.arm.com/documentation/dui0068/b/ARM-Instruction-Reference">Oh boy</a>. I read a bit, and felt that I understand some, but it was far from my naive 3-instruction view of the world. And even if I understood enough, I realized I'd be super platform dependent, which doesn't feel very appealing.</p>
<p>I haven't touched or thought very much about assembly since then.</p>
<h2>Back to WASM</h2>
<p>With this in mind, the mention of <a href="https://webassembly.org">web assembly</a> came at an interesting time for me. I now knew that assembly computing could be pretty enjoyable, and I also had built up a need for a simple way to play around with assembly, but that was more flexible than uxn. While I think uxn is cool, I'm not sure I want the restrictions.</p>
<p>WASM seems pretty diverse to me, with a bunch of different projects going on. For my goals, this combination appealed to me:</p>
<ul>
<li><a href="https://github.com/bytecodealliance/wasmtime">wasmtime</a> -- wasm runtime for desktops</li>
<li><a href="https://github.com/WebAssembly/wabt">wabt</a> -- tons of tools, including wat2wasm: compile wasm text files (.wat) to binary (.wasm)</li>
<li><a href="https://wasi.dev">wasi</a> -- system interface for WASM (think libc)</li>
<li><a href="https://github.com/bjorn3/browser_wasi_shim">browser_wasi_shim</a> -- wasi interface for browser</li>
</ul>
<p>I've just started (like 2 hours ago), but so far I managed to create a little example repo that I feel happy about. Check it out <a href="https://github.com/saikyun/wasm-wasi-hello-world">here</a>.</p>
<pre><code>wasmtime hello-world-wasi.wat
hello world
</code></pre>
<p>What I did was pull together examples from the projects mentioned above, and managed to run a program printing <code>hello world</code> in both the browser and on my macbook, using wasmtime. It's not much, but it's still cool to be able to hand write assembly code and have it do stuff and run on multiple platforms. :)</p>
<p>#100DaysToOffload</p>

<hr />

<h1>Thought loops</h1>
<p>Inspired by <a href="https://bjoreman.com">Fredrik Bj√∂reman</a> I decided to create my own blog. In his podcast <a href="https://kodsnack.se/508/">Kodsnack</a> he and <a href="https://6510.nu/@krig">Kristoffer</a> talks about getting stuff out without thinking too much.</p>
<p>I felt this very hard, as I've been stuck in some thought loops lately. If I were to describe it as shortly as I could, this would be my attempt:</p>
<ol>
<li>
<p>I want to be able to create graphical applications and games, that can run on as many platforms as possible, with live coding capabilities</p>
</li>
<li>
<p>To fulfill this, I created <a href="http://github.com/saikyun/freja">Freja</a>, a code editor that can be modified withing itself, and therefore create GUIs and games without ever closing the applications</p>
<p>2.1. Well, that was the idea anyway, but I still have problems like ending up in an infinite loop and needing to restart</p>
<p>2.2. The bigger issue however, is that the GUI lib I wrote doesn't work well enough. Tons of tiny bugs that pop up whenever I try to create new GUI</p>
<p>2.3. I also don't quite agree with the language I use, <a href="https://janet-lang.org">Janet</a>, which is a super cozy lisp, but has some other ideas about live coding / redefining functions during runtime, which are not hopeless to overcome, but often a bit in the way. This is in no way the fault of the language, it just has slightly different goals than I have.</p>
</li>
<li>
<p>Despair</p>
</li>
<li>
<p>I've tried Unity and Godot, and while I dislike the former (extremely sluggish, and the minor point that C# feels like a nice, safe car but sooo boring -- where is my meta programming!?), I can withstand the latter. It's snappy and nice, has basic hot reload, but I personally feel the OOPiness (specifically no interfaces and tons of inheritance) makes for a less cozy environment for me.</p>
</li>
<li>
<p>Now I'm standing here, wondering what to do with my situation. I feel like I don't have a cozy place to code, but I'm not sure I'm ready to rewrite the GUI library. I'm also thinking about writing it in C, a language which I've gotten a lot more love for, since learning that hot reloading DLLs is surprisingly viable. But C lacks some things I want (multiple dispatch, dynamic arrays). I've tried to remedy this with macros, but it still feels a bit icky. Like I'm trying to make the language be something it's not.</p>
</li>
</ol>
<p>So here I am. I've experimented a lot, e.g. making C more dynamic (changing structs during runtime), compiling lisp to C, playing around with type unification. But I have no clue where to go.</p>
<p>#100DaysToOffload</p>
