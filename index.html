<!DOCTYPE html>
<html>
<head>
  <title>Saikyun</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
</head>
<style>
  body {
    max-width: 800px;
    margin: 0 auto;
  }

  hr {
    margin: 100px 0px;
    visibility: hidden;
  }
</style>
<body>

<h1 id="getting-used-to-bad-things"><a href="#getting-used-to-bad-things">Getting used to bad things</a></h1>
<p>I think there are more people than me who are good at getting used to bad things.</p>
<p>I used to code lisp in emacs, and what's amazing about it, is that you can use <a href="http://danmidwood.com/content/2014/11/21/animated-paredit.html">Paredit</a> (and other structural editing tools, like those built into emacs) which let's you treat the code like a branching road where you can move towns and lakes around, rather than erase individual characters. The most obvious example in my mind are languages where <code>,</code> separates &quot;things&quot;, e.g.:</p>
<pre><code>int sum(int curr, int acc)
</code></pre>
<p>In this situation, if you want to switch the place of <code>int curr</code> and <code>int acc</code>, you have to do this awkward dance of selecting <code>acc</code>, cutting it, moving the cursor to <code>curr</code>, paste it, select <code>curr</code>, cut it, move the cursor back to where <code>acc</code> used to be, paste. If there were no <code>,</code>, at least you could just select and cut the whole <code>int acc</code>, move the cursor to right after <code>(</code>, and paste, hit space, and remove the trailing space at the end. There are many variants on this, and if you're anything like me, you notice when these awkward things happen. And there's not really a clean solution.</p>
<p><a href="https://calva.io/images/paredit/transpose.gif">That's not true in lisp.</a></p>
<p>You just do a single command, <code>transpose-sexp</code> (preferably bound to a hotkey). And when you want to move multiple expressions that are in the same block, let's say you have code like this: <code>(curr :int acc :int)</code>, then at least you can stand in the middle, hit <code>Ctrl+K</code> which cuts until right before the closing <code>)</code>, then move to the beginning of the expression, then paste. At least you don't have to fiddle with selecting single characters.</p>
<p>But I've gotten used to not having it, after sitting in C-based languages for more than a year. And it's very sad.</p>
<p>Of course there are a lot worse things to get used to, like depression, abuse and plastic accumulating in our nature.</p>
<p>Still though, I wonder if there's a connection. If you allow yourself to get used to one thing that you can affect, but don't. Do you get better at getting used to bad things?</p>
<p><em>#100DaysToOffload - Please say hi on <a href="https://mastodon.social/@saikyun">mastodon.social/@saikyun</a>. :)</em></p>


<hr />

<h1 id="productivity"><a href="#productivity">Productivity</a></h1>
<p>I wanted to name this Tired, but I already made that post, so let's do something else.</p>
<p>During the weekend, I listened to 90% of the second episode of <a href="https://synk.fm/podcast/2-en-snurra-varje-dag/">Synk</a>. In this episode, Fredrik and Martin talks about productivity and productivity tools (like papers and pens and Obsidian). I don't care about productivity, I just wanted to listen to them talk about something that isn't game development, because I've spent the last 5 years of my life listening to game development podcasts.</p>
<p>One of the things I like about Fredrik is that he tends to question things. So when he said he didn't necessarily do Orthodox GTD, but still enjoyed <a href="https://www.reddit.com/r/gtd/comments/b6ok53/gtd_fast_not_sure_how_long_it_will_be_up_for/">these seminars by the author of the GTD book</a>, I was intrigued. I want to listen to people talk, and here's a person I like hearing talk saying I should listen to this other person talk. So I did.</p>
<p>First, the speaker (David Allen), feels very chill. I thought he'd be a stuffy business person, something I felt when trying to listen to Eat That Frog (some other productivity book thing). So it's just enjoyable to listen to him.</p>
<p>Secondly, his focus on being lazy, and that you should be able to enjoy all of life, not just work, made me feel that maybe he has something sensible to say.</p>
<p>So I kept listening for a bit while jog/walk/jogging today (maybe half an hour), and I'm still feeling &quot;nah, I don't need this productivity stuff, my memory is doing all right. the important things are always in front of me&quot;. But with his comment about &quot;collecting notes&quot; still ringing in my ears, I start noticing all the little problems at home that I have some intention to solve, and have not solved. Here's a sample:</p>
<ul>
<li>Out of milk</li>
<li>Three bottles of lotion of which two are almost empty</li>
<li>I have no job</li>
<li>Three bags of cardboard that needs to be recycled</li>
<li>A pot of potato soup has been on the balcony since february</li>
<li>A horde of bath toys next to the shower that are never used</li>
<li>Plan for working on my son's daycare tomorrow (e.g. eat lunch in time (which means buying lunch in time), bring something gluten free to eat between lunch and dinner (which means buying something gluten free))</li>
</ul>
<p>Of course, all of these things are in front of me from time to time. But I don't keep them in mind for when I have time to deal with them. This is obvious stuff, but I have felt so anxious about having todo lists that I don't have time or energy to go through, that I've convinced myself the best solution is to have no list at all. But I'm starting to come around to the thought that I might be wrong. Maybe it's better to have the lists, and even if I haven't solved everything, at least I can think: &quot;well, it's on the list, and when I have time and energy, I can go through the list and solve it.&quot;</p>
<p>I don't need to keep it in my mind.</p>
<p><em>#100DaysToOffload - Please say hi on <a href="https://mastodon.social/@saikyun">mastodon.social/@saikyun</a>. :)</em></p>

<hr />

<h1 id="rest-day"><a href="#rest-day">Rest Day</a></h1>
<p>Today it is sunday.</p>
<p>For a while, I tried having a rule that I shouldn't code on sundays. I had this feeling that I was tiring myself out, and not giving myself enough time to recover. Sundays felt very boring, and I was often tired. Implementing this rule, it felt worse. Now I had nothing meaningful to do. And since I was tired, I had a hard time coming up with things to do. But over time, I started to appreciate this tired feeling.</p>
<p>As long as I don't fight against it, it's not dangerous. It's just there. And since I'm not allowed to code, there's not really that much actually hard things to do. I can clean the kitchen even if I feel sluggish. I can watch youtube with my son.</p>
<p>After getting laid off though, I felt pressure to create a game quickly, and tried to spend as much time as possible on it, including sundays. In the beginning, it was pretty easy. I got some sort of energy rush after being laid off. But then it went as with most projects, after three weeks or so, the hype died down. Me and my family got a long bout of colds and infections in the middle of it as well, so it wasn't really feasible to struggle so hard to create something quickly. My wife also commented on that I didn't seem as happy, now that I was working on sundays as well again.</p>
<p>(In case you're wondering, it was supposed to be a hexagonal, <a href="http://www.roguebasin.com/index.php/Berlin_Interpretation">berlin interpretation roguelike</a> with <a href="https://youtu.be/urL6ZFOXbCA">trains</a>. I played a bit of <a href="https://www.cavesofqud.com">Caves of Qud</a> which inspired me to try to create something with less graphics and more code. However, I quickly ended up having to draw a lot, which meant I spent a lot of time not making fun gameplay. I think this helped kill my motivation.)</p>
<p>After letting myself just enjoy empty days, rather than forcing myself to produce, I've felt that I've started to recover from my last job. I think I was more stressed than I realized, and since I experienced burn out (with sleeplessness and extreme difficulties concentrating) at my last job, I imagine I'm more stress sensitive than most.</p>
<p>I've recently managed to jog often as well. I've been wanting to jog for about ten years, ever since reading Murakami's <a href="https://www.goodreads.com/book/show/2195464.What_I_Talk_About_When_I_Talk_About_Running">&quot;What I Talk About When I Talk About Running&quot;</a>. I never found a way to do it sustainably though. In the beginning, I just tried running for about 10 minutes straight, then increasing by 1-2 minutes every day. I think I lasted two weeks, then I started getting a lot of pain (I think in my knee, but I can't quite remember). I tried taking a short break, but it felt like no matter how long my break was, the pain instantly came back. Knowing myself as a 22-year old, I don't think I had the patience to wait weeks or months, and try again. So I quit, for many years. I've tried from time to time after that, but due to my <a href="https://en.wikipedia.org/wiki/Ehlers%E2%80%93Danlos_syndromes">EDS</a> various parts of my body are very sensitive, e.g. knees, feet and my back.</p>
<p>But this year, I think I finally found a combination of things that actually work. I'm using <a href="https://cdn.sportshop.com/catalog/product/580/580/1/0/109747_1.jpg">Hoka shoes</a> which have bizarrely large soles (I tried <a href="https://runon.se/images/thumbs/000/0003907_joe-nimble-w-nimbletoes-addict-road-blackout-dam.jpeg">flat shoes with very little soles</a> before that but it didn't work for me). I'm also doing the &quot;Run/Walk/Run&quot; thing, which for me meant in the beginning to stretch, walk for 5 minutes, do 10x 20s jog, 40s walk, walk for 5 minutes. Now I'm up to 22x 30s jog, 30s walk, and I've managed to keep it up even after getting sick, which is incredibly motivating for me, because getting sick tends to break all my forming habits.</p>
<p>I think this newfound ability to jog has helped me a lot in my recovery. I sleep well, despite now being completely sleep medication free. I also don't get as sensitive to days when I sleep worse. So overall my mood is better.</p>
<p>Then I ended up listening to the Kodsnack episode mentioned <a href="#thought-loops">in my first blog post</a>. And they said people should just start blogging. So I did! And all of a sudden my brain started connecting things again, I could think more clearly, and deeper than I have been able to for a while. So of course I start coding again. My motivation got an extreme boost, and now I feel like I have the capability to pull through. What's best is that I have no illusion of being able to make money of a niche programming language (well, I guess <a href="https://ziglang.org/news/announcing-zig-software-foundation/">one can hope</a>, but there isn't as much buzz as with games). I believe this helps me feel that this is more of a hobby than a job.</p>
<p>Still though, I don't want to risk my newfound energy. Therefore I resolve to not code on sundays. That way, I will at least have one restful day. And I'm also going to try not to write about code on sundays. I can write about my feelings about code, but not get into technical stuff.</p>
<p>Hope you'll also enjoy a restful sunday. :) My and my wife gonna get to watch my son's first dance performance, so I know I will!</p>
<p><em>#100DaysToOffload - Please say hi on <a href="https://mastodon.social/@saikyun">mastodon.social/@saikyun</a>. :)</em></p>

<hr />

<h1 id="time"><a href="#time">Time</a></h1>
<p>It's hard for me how to know how to spend my time.</p>
<p>Sometimes I feel like I spend too little time with my son. At the same time, I think it can be hard to get all the things done while also getting time to spend with my son. And even if I get time to spend with my son, it can feel hard to find time to spend with my wife. And if I get both of those, it's hard to find time to spend with my wife and son at the same time. And then someone get's sick while we're at the playground. And now we have even less time to go buy food. So they eat leftovers, and I boil some rice. But now it's the day after that day, and now I have to buy breakfast before I can eat breakfast, and now I get less time to spend with my son.</p>
<p>Also I spent two hours watching this fascinating lecture about <a href="https://www.youtube.com/watch?v=Ge3aKEmZcqY">performance in programming</a>.</p>
<p><em>#100DaysToOffload - Please say hi on <a href="https://mastodon.social/@saikyun">mastodon.social/@saikyun</a>. :)</em></p>

<hr />

<a href="#tired"><h1 id="tired">Tired</h1></a>
<p>Yesterday I had seemingly endless amounts of energy. And today I feel very tired. If this had been a regular workday,
  I would have been whipping myself over the lack of productivity. Luckily, I'm currently on paid leave, so I don't have
  to worry so much.</p>
<p>Until I start thinking about how I will soon die, of course.</p>
<p>In the face of that, tired days can really feel like a waste. I think I've come up with a spell that helps though.
  What I've thought is something like this:</p>
<ul>
  <li>
    <p>If you try to get good at something -- let's say drawing -- and it takes ten years, but you die after five, is it
      meaningful?</p>
  </li>
  <li>
    <p>If it is not, then you should probably not be drawing. I mean, even if you didn't die, you might get injured, or
      you might get tired of drawing, or your life changes in such a way that you can't spend as much time on drawing.
    </p>
  </li>
  <li>
    <p>Therefore, it must be meaningful, even if we don't get good at it.</p>
  </li>
  <li>
    <p>In that case, what happens if you spend half as much time on drawing per week, and it would take 20 years to get
      good at it? The numbers are different, but the equation is the same, right? You might die after 5 or 10, it
      doesn't matter really. Even if you die after 1 day, it must still be meaningful.</p>
  </li>
</ul>
<p>With this in mind, it doesn't matter if you are tired one day, because the striving toward getting good at drawing is
  worth it anyway.</p>
<p>And if it isn't, you should probably quit.</p>
<p>#100DaysToOffload</p>

<p>Please say hi on <a href="https://mastodon.social/@saikyun">mastodon.social/@saikyun</a>. :)</p>

<hr />

<a href="#making-a-lisp-in-c"><h1 id="making-a-lisp-in-c">Making a Lisp in C</h1></a>
<p>Today I started working on a lisp in c. I want the lisp to compile to C. I've tried it before, but the first time I
  got stuck on figuring out what types things should be (assuming I don't want to fill out all the types all the time in
  lisp). Since then I've done some basic work on <a
    href="https://github.com/saikyun/unification/tree/10b19ae798b508127fb54fa68ed218c99bdd23f4">unification</a> / type
  inference. When I tried my first lisp in c, I only found research papers about unification, which I had trouble
  understanding. I wasn't sure how to learn how to read them either, and ended up listening to <a
    href="https://en.wikipedia.org/wiki/Tractatus_Logico-Philosophicus">Tractatus Logico-Philosophicus</a>. It didn't
  work very well in audiobook form, and it definitely did not help me understand how to read science papers with strange
  symbols.</p>
<p>Since then, a friend showed me https://eli.thegreenplace.net/2018/unification/ which talked my language a lot better.
  So I was able to do the basic stuff, finally.</p>
<p>I did start on <a href="https://github.com/saikyun/lisp-to-c">another lisp in c</a> after writing that unification
  stuff. While I did manage to compile some C from lisp, I got a bit stuck trying to figure out how enable macros (i.e.
  running lisp while still being in the compilation phase). At least I think that's what happened. I started some work
  on doing both <code>eval</code> and <code>compile</code>, i.e. an interpreter <em>and</em> a compiler. But it seemed
  like I would have to write a lot of the same code over and over again.</p>
<p>What I've figured out now is that I somehow want to be able to:</p>
<ol>
  <li>Compile lisp code to C</li>
  <li>Evaluate lisp code while in the compilation phase, using the same code as step 1. does</li>
</ol>
<p>This seemed tricky, since I didn't know of a way to get <code>eval</code> for C. Then I remembered that my friend
  told me about <a href="https://bellard.org/tcc/">tcc</a>. tcc is a tiny c compiler, that is easy to build and bundle
  with your project. Even in the 2nd iteration, I figured I'd use tcc to generate dlls to facilitate live coding. What I
  didn't realize back then, but figured out now when reading the docs, is that you can <em>use tcc as a library</em>,
  and <em>compile functions to memory</em>.</p>
<p><a href="https://github.com/saikyun/libtcc-example">I tried that.</a> It's very awesome. Suddenly you have eval in C.
</p>
<p>This means that if I encounter a macro during compilation, I can call some libtcc functions, and get some results,
  and then use those results when continuing compilation. Pretty cool!</p>
<p>I'm also guessing it'll make live coding ever so slightly faster, since I won't have to start a separate process,
  compile a dll/so to disk, <code>dlload</code> that dll, e.t.c.</p>
<h2>Third time's the charm</h2>
<p>So now I'm starting again, this time using only C, and trying to make sure everything works with tcc. Sadly I had
  some <a href="https://lists.nongnu.org/archive/html/tinycc-devel/2023-04/msg00029.html">problems building binaries</a>
  on my macbook air m2, but <code>tcc -run</code> does work. So hopefully it can be sorted out.</p>
<p>Ofc what I probably &quot;should&quot; do is either use llvm, or go all the way and just interact with assembly
  directly, but both those have their problems.</p>
<p>First off, llvm just seems to have slower compile times overall than tcc. Of course it then wins hugely during
  runtime, but that's not important for <code>eval</code>. My language should be able to AOT compile as well, and then
  I'd use clang / gcc / cl. But when coding, I figure tcc will speed up development a lot.</p>
<p>Doing something with assembly, instead of having the middle step of C, appeals to me a lot, but I know next to
  nothing about assembly, while I can do basic stuff in C. And even if I were to learn some sort of assembly, I would be
  tied hard to whatever platform I decided to learn. With tcc it seems feasibly to build/eval on all desktop platforms,
  and maybe the browser and phones.</p>
<p>And since my language will build to C in the end, I figure that when you're done coding and want to build binaries,
  it should be possible to build them for all manners of platforms, including consoles. You lose <code>eval</code>, but
  while it's a bit boring to lose it, it's not as crucial as it is while developing.</p>
<p>So far I've built the <a href="https://app.slack.com/client/T024SRSB2/C011CD5P1S6">tokenizer</a>. Not much to look at
  yet. But hopefully it won't be too long until I can call some C functions using my lisp. :)</p>
<p>#100DaysToOffload</p>

<p>Please say hi on <a href="https://mastodon.social/@saikyun">mastodon.social/@saikyun</a>. :)</p>

<hr />

<a href="#coding-with-chatgpt"><h1 id="coding-with-chatgpt">Coding with ChatGPT</h1></a>
<p>After I played around with wasm yesterday, I talked to a friend. He got me inspired to try some <a
    href="https://openai.com/blog/chatgpt">ChatGPT</a> coding. I started out making a lisp parser in rust. It turned out
  pretty well, after some massage and asking it to change things. For example, it used <code>&amp;str</code> without
  explicit lifetimes, which Rust didn't like. I could tell it to add the explicit lifetimes though, but now the code
  looked disgusting.</p>
<p>I bought the premium version and tried gpt4, and it instead used <code>String</code> (which seems sensible, and looks
  a lot nicer), but now it did tokenizing and parsing at the same time, which makes the code raise my upper lip in
  disgust.</p>
<p>It's a very different feeling from hand coding things. Like pushing a river. You can affect it, but it's hard to
  control, and sometimes you get chaotic whirls that the compiler and I don't like.</p>
<p>After the lisp parser, &quot;we&quot; made the evaluator. At first it had a big <code>match</code> where it would put
  functions like <code>+</code> as a case. But I wanted it instead to look up symbols in an environment, and have
  certain symbols be added to the environment by default. I asked it to do this, and it actually rewrote the code. That
  was pretty cool! Still some manual labour on top, but it's the sort of change that can feel hard to switch to, when
  you've already coded in a different style.</p>
<p>I should mention that from nothing to evaluator took about an hour. I think that's faster than I could have written
  it by hand, and it's definitely faster than it would have taken me to write it in Rust, since I'm a bit rusty.</p>
<pre><code>cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.01s
     Running `target/debug/lisp`
List([Symbol(&quot;+&quot;), Number(1.0), List([Symbol(&quot;*&quot;), Number(2.0), Number(3.0)])])
Result: 7
</code></pre>
<p>I tried some other stuff, like generating example Clojure code to use as a test, something to implement in my own
  lisp. It was kind of hilarious, because it missed a closing parens. Even AI can't write lisp. :') <a
    href="http://danmidwood.com/content/2014/11/21/animated-paredit.html">Paredit</a> ftw. If you haven't checked out
  structural programming at all, I recommend just looking at those beautiful gifs.</p>
<p>One thing ChatGPT has over me is how quickly it can switch between different tasks. Despite me feeling tired, I felt
  that I could get a momentum boost by seeing it's code, wether it was correct or not. It's like giving me a space where
  it already has filled out the little calls that I might have forgotten (how did I split a string with a regex in
  Clojure again?). It was also nice to get some Rust examples, since I haven't used it in 6 years.</p>
<p>After that, I tried making a card game using TypeScript. I started out having it give me examples using canvas (e.g.
  a function that renders playing cards), but I quickly felt that I wanted some abstractions over loading sprites and
  handling user input. Maybe that was wrong, but that was how I felt.</p>
<p>This is where I felt chatgpt became very annoying to use. I tried to have it give me examples for using PixiJS, then
  Phaser, then P5. And over and over again it resulted in strange typescript errors. I'm sure there might have been
  configuration somewhere that's strange, or I was using old examples or something. But overall it felt really
  unpleasant, and took way too much time. It might have more to do with the TypeScript + npm + webpack/parceljl/???
  combination that easily leads to a silly amount of things that can go wrong.</p>
<p>After getting over the hurdle of getting something to draw a rectangle on the screen (which ended up being easiest
  with p5), &quot;we&quot; started adding things like a deck, hands of cards, a play zone etc. It felt all right, but I
  felt a lot less helped than when it wrote the parser. My guess is that the parser is more well defined, and it's the
  sort of thing that's easy to get wrong as a human, while coding game mechanics has more to do with positioning things
  on the screen and moving things between different collections.</p>
<p>Another point for ChatGPT was asking for math with natural language:</p>
<pre><code>Can you give me an easing function in javascript, that starts out slow, then fast, then slow in the middle, then fast again?
</code></pre>
<pre><code>Yes, you can use the &quot;easeInOutQuad&quot; easing function in JavaScript to achieve the desired effect. Here is the code for the function:

function easeInOutQuad(t, b, c, d) {
  t /= d/2;
  if (t &lt; 1) return c/2*t*t + b;
  t--;
  return -c/2 * (t*(t-2) - 1) + b;
}
</code></pre>
<p>This is the sort of code I could figure out, but it takes me a long time and I don't enjoy it. I believe asking it
  for help with vector math can come in handy as well.</p>
<p>The most important thing I learned, is that I enjoy coding a lot more than doing code reviews. So I'll probably keep
  hand coding for as long as I can. :)</p>
<p>#100DaysToOffload</p>

<p>Please say hi on <a href="https://mastodon.social/@saikyun">mastodon.social/@saikyun</a>. :)</p>

<hr />

<a href="#web-assembly"><h1 id="web-assembly">Web Assembly</h1></a>
<p>Yesterday I posted my first blog on <a href="http://kodsnack.se">Kodsnack</a>'s slack channel, and got some feedback
  on my woes about programming.</p>
<p>Some said that zig and r*** might be good languages to look at, and I argued a bit about how they appear to me as
  languages that doesn't have the same goals in mind as me. I think being able to (compile and) execute code with
  &lt;200ms delay is important, since I find it pleasant when working on things like animations and layouts. Needing to
  wait even a second while modifying an animation feels painful to me.</p>
<p>I want to be clear and say that I do think zig and rust are interesting (and probably good) languages, and it's a
  difference in priorities and aesthetics, not in some objective &quot;good&quot;ness. So if you do enjoy zig / rust,
  please keep rocking on. :)</p>
<p>I also got some kind words about <a href="https://github.com/saikyun/freja">Freja</a>, which I really appreciate.</p>
<p>The last thing that came up was the subject of WASM. Being interested in both web and games, I've been curious about
  WASM since it's inception. I still remember playing some Quake or DOOM demo in the browser, and it seemed kind of
  magical. I never did anything with it though, since at the time I was busy writing web apps in node and play League of
  Legends.</p>
<p>Last summer I started wondering if assembly is a good target for live coding, since it's very flexible (just swap out
  the byte code right?). It seemed very tricky to write a multi platform compiler though.</p>
<p>When camping with my family, I started reading about <a href="https://100r.co/site/uxn.html">uxn</a>, and <a
    href="https://wiki.xxiivv.com/site/paper_computing.html">pen &amp; paper computing</a>).</p>
<p>In the paper prototyping site, they mention that you can compute using a really small instruction set:</p>
<blockquote>
  <p>The following three counter machine models have the same computational power since the instructions of one model
    can be derived from those of another:</p>
</blockquote>
<blockquote>
  <p>INC(r), DEC(r), JZ(r, z) - Minsky (1961, 1967), Lambek (1961)</p>
</blockquote>
<blockquote>
  <p>CLR(r), INC(r), JE(rj, rk, z) - Ershov (1958), Peter (1958)</p>
</blockquote>
<blockquote>
  <p>INC(r), CPY(rj, rk), JE(rj, rk, z) - Elgot-Robinson (1964), Minsky (1967)</p>
</blockquote>
<p>With this knowledge, I made a assembly editor and interpreter using termux. It was pretty fun, and it really
  fulfilled the minimalist language that I envisioned. It was pretty cool that you see how the registers changed when
  you ran the program too.</p>
<p>Next step was obviously to make this compile to arm assembly. Arm is the simple one, right? <a
    href="https://developer.arm.com/documentation/dui0068/b/ARM-Instruction-Reference">Oh boy</a>. I read a bit, and
  felt that I understand some, but it was far from my naive 3-instruction view of the world. And even if I understood
  enough, I realized I'd be super platform dependent, which doesn't feel very appealing.</p>
<p>I haven't touched or thought very much about assembly since then.</p>
<h2>Back to WASM</h2>
<p>With this in mind, the mention of <a href="https://webassembly.org">web assembly</a> came at an interesting time for
  me. I now knew that assembly computing could be pretty enjoyable, and I also had built up a need for a simple way to
  play around with assembly, but that was more flexible than uxn. While I think uxn is cool, I'm not sure I want the
  restrictions.</p>
<p>WASM seems pretty diverse to me, with a bunch of different projects going on. For my goals, this combination appealed
  to me:</p>
<ul>
  <li><a href="https://github.com/bytecodealliance/wasmtime">wasmtime</a> -- wasm runtime for desktops</li>
  <li><a href="https://github.com/WebAssembly/wabt">wabt</a> -- tons of tools, including wat2wasm: compile wasm text
    files (.wat) to binary (.wasm)</li>
  <li><a href="https://wasi.dev">wasi</a> -- system interface for WASM (think libc)</li>
  <li><a href="https://github.com/bjorn3/browser_wasi_shim">browser_wasi_shim</a> -- wasi interface for browser</li>
</ul>
<p>I've just started (like 2 hours ago), but so far I managed to create a little example repo that I feel happy about.
  Check it out <a href="https://github.com/saikyun/wasm-wasi-hello-world">here</a>.</p>
<pre><code>wasmtime hello-world-wasi.wat
hello world
</code></pre>
<p>What I did was pull together examples from the projects mentioned above, and managed to run a program printing
  <code>hello world</code> in both the browser and on my macbook, using wasmtime. It's not much, but it's still cool to
  be able to hand write assembly code and have it do stuff and run on multiple platforms. :)</p>
<p>#100DaysToOffload</p>

<p>Please say hi on <a href="https://mastodon.social/@saikyun">mastodon.social/@saikyun</a>. :)</p>

<hr />

<a href="#thought-loops"><h1 id="thought-loops">Thought loops</h1></a>
<p>Inspired by <a href="https://bjoreman.com">Fredrik Björeman</a> I decided to create my own blog. In his podcast <a
    href="https://kodsnack.se/508/">Kodsnack</a> he and <a href="https://6510.nu/@krig">Kristoffer</a> talks about
  getting stuff out without thinking too much.</p>
<p>I felt this very hard, as I've been stuck in some thought loops lately. If I were to describe it as shortly as I
  could, this would be my attempt:</p>
<ol>
  <li>
    <p>I want to be able to create graphical applications and games, that can run on as many platforms as possible, with
      live coding capabilities</p>
  </li>
  <li>
    <p>To fulfill this, I created <a href="http://github.com/saikyun/freja">Freja</a>, a code editor that can be
      modified withing itself, and therefore create GUIs and games without ever closing the applications</p>
    <p>2.1. Well, that was the idea anyway, but I still have problems like ending up in an infinite loop and needing to
      restart</p>
    <p>2.2. The bigger issue however, is that the GUI lib I wrote doesn't work well enough. Tons of tiny bugs that pop
      up whenever I try to create new GUI</p>
    <p>2.3. I also don't quite agree with the language I use, <a href="https://janet-lang.org">Janet</a>, which is a
      super cozy lisp, but has some other ideas about live coding / redefining functions during runtime, which are not
      hopeless to overcome, but often a bit in the way. This is in no way the fault of the language, it just has
      slightly different goals than I have.</p>
  </li>
  <li>
    <p>Despair</p>
  </li>
  <li>
    <p>I've tried Unity and Godot, and while I dislike the former (extremely sluggish, and the minor point that C# feels
      like a nice, safe car but sooo boring -- where is my meta programming!?), I can withstand the latter. It's snappy
      and nice, has basic hot reload, but I personally feel the OOPiness (specifically no interfaces and tons of
      inheritance) makes for a less cozy environment for me.</p>
  </li>
  <li>
    <p>Now I'm standing here, wondering what to do with my situation. I feel like I don't have a cozy place to code, but
      I'm not sure I'm ready to rewrite the GUI library. I'm also thinking about writing it in C, a language which I've
      gotten a lot more love for, since learning that hot reloading DLLs is surprisingly viable. But C lacks some things
      I want (multiple dispatch, dynamic arrays). I've tried to remedy this with macros, but it still feels a bit icky.
      Like I'm trying to make the language be something it's not.</p>
  </li>
</ol>
<p>So here I am. I've experimented a lot, e.g. making C more dynamic (changing structs during runtime), compiling lisp
  to C, playing around with type unification. But I have no clue where to go.</p>
<p>#100DaysToOffload</p>

<p>Please say hi on <a href="https://mastodon.social/@saikyun">mastodon.social/@saikyun</a>. :)</p>

</body>
</html>